<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mnemonas&#39;semiware: network::LinearNonLinearTransform Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://vthierry.github.io/mnemonas"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mnemonas&#39;semiware
   </div>
   <div id="projectbrief">Implementation of a Mnemonas semiware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetwork.html">network</a></li><li class="navelem"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html">LinearNonLinearTransform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnetwork_1_1LinearNonLinearTransform-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">network::LinearNonLinearTransform Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a recurrent network as a non-linear affine combination of input and recurrent values.  
 <a href="classnetwork_1_1LinearNonLinearTransform.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LinearNonLinearTransform_8hpp_source.html">LinearNonLinearTransform.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for network::LinearNonLinearTransform:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnetwork_1_1LinearNonLinearTransform.png" usemap="#network::LinearNonLinearTransform_map" alt=""/>
  <map id="network::LinearNonLinearTransform_map" name="network::LinearNonLinearTransform_map">
<area href="classnetwork_1_1KernelTransform.html" title="Defines a discrete-time recurrent input/output kernel transform. " alt="network::KernelTransform" shape="rect" coords="0,168,214,192"/>
<area href="classnetwork_1_1RecurrentTransform.html" title="Defines a discrete-time recurrent input/output transform. " alt="network::RecurrentTransform" shape="rect" coords="0,112,214,136"/>
<area href="classnetwork_1_1Transform.html" title="Defines an input/output transform. " alt="network::Transform" shape="rect" coords="0,56,214,80"/>
<area href="classnetwork_1_1Input.html" title="Defines the input of a calculation network. " alt="network::Input" shape="rect" coords="0,0,214,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad1b3138ecf9ee9311dc976ae252ddc47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#ad1b3138ecf9ee9311dc976ae252ddc47">LinearNonLinearTransform</a> (unsigned int N, const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;<a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a>, double min=0, double max=1)</td></tr>
<tr class="memdesc:ad1b3138ecf9ee9311dc976ae252ddc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the transform for the given parameters.  <a href="#ad1b3138ecf9ee9311dc976ae252ddc47">More...</a><br /></td></tr>
<tr class="separator:ad1b3138ecf9ee9311dc976ae252ddc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d9519a67bfbe56017dc7134a24398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html">LinearNonLinearTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#ad12d9519a67bfbe56017dc7134a24398">setLeak</a> (double value=0)</td></tr>
<tr class="memdesc:ad12d9519a67bfbe56017dc7134a24398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a fixed common leak for this network.  <a href="#ad12d9519a67bfbe56017dc7134a24398">More...</a><br /></td></tr>
<tr class="separator:ad12d9519a67bfbe56017dc7134a24398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d028cfab0d62f57e291148403ec361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html">LinearNonLinearTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#ab9d028cfab0d62f57e291148403ec361">setOffset</a> (double value=0)</td></tr>
<tr class="memdesc:ab9d028cfab0d62f57e291148403ec361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a fixed common offset for this network.  <a href="#ab9d028cfab0d62f57e291148403ec361">More...</a><br /></td></tr>
<tr class="separator:ab9d028cfab0d62f57e291148403ec361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba94b5729e4757f472b995bdac593b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#aeba94b5729e4757f472b995bdac593b0">setWeight</a> (unsigned int n, unsigned int d, double w)</td></tr>
<tr class="memdesc:aeba94b5729e4757f472b995bdac593b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one weight <img class="formulaInl" alt="$W_{nd}$" src="form_93.png"/> value.  <a href="#aeba94b5729e4757f472b995bdac593b0">More...</a><br /></td></tr>
<tr class="separator:aeba94b5729e4757f472b995bdac593b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a3472af1a3934f8824586dbf701024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetwork_1_1KernelTransform.html">KernelTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#a90a3472af1a3934f8824586dbf701024">setWeights</a> (const <a class="el" href="classnetwork_1_1KernelTransform.html">KernelTransform</a> &amp;network)</td></tr>
<tr class="memdesc:a90a3472af1a3934f8824586dbf701024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets weights from another network of the same type.  <a href="#a90a3472af1a3934f8824586dbf701024">More...</a><br /></td></tr>
<tr class="separator:a90a3472af1a3934f8824586dbf701024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02badcd07dba1d066a5471082851a5ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#a02badcd07dba1d066a5471082851a5ce">getKernelDimension</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a02badcd07dba1d066a5471082851a5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recurrent kernel dimension.  <a href="#a02badcd07dba1d066a5471082851a5ce">More...</a><br /></td></tr>
<tr class="separator:a02badcd07dba1d066a5471082851a5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f34369e316221ac0df9cf146710a5e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#a68f34369e316221ac0df9cf146710a5e">getKernelValue</a> (unsigned int n, unsigned int d, double t) const</td></tr>
<tr class="memdesc:a68f34369e316221ac0df9cf146710a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recurrent kernel value.  <a href="#a68f34369e316221ac0df9cf146710a5e">More...</a><br /></td></tr>
<tr class="separator:a68f34369e316221ac0df9cf146710a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a2543d39307d2b02ea6c67d4923a4b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#ae9a2543d39307d2b02ea6c67d4923a4b">getKernelDerivative</a> (unsigned int n, unsigned int d, double t, unsigned int n_, double t_) const</td></tr>
<tr class="memdesc:ae9a2543d39307d2b02ea6c67d4923a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recurrent kernel derivative with respect to a recurrent state value.  <a href="#ae9a2543d39307d2b02ea6c67d4923a4b">More...</a><br /></td></tr>
<tr class="separator:ae9a2543d39307d2b02ea6c67d4923a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a6ee5939a5051ac924e0448d76ecfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#a13a6ee5939a5051ac924e0448d76ecfd">isConnected</a> (unsigned int n, double t, unsigned int n_, double t_) const</td></tr>
<tr class="memdesc:a13a6ee5939a5051ac924e0448d76ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two units are connected.  <a href="#a13a6ee5939a5051ac924e0448d76ecfd">More...</a><br /></td></tr>
<tr class="separator:a13a6ee5939a5051ac924e0448d76ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnetwork_1_1KernelTransform"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnetwork_1_1KernelTransform')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnetwork_1_1KernelTransform.html">network::KernelTransform</a></td></tr>
<tr class="memitem:a498657a20ee5f8e3dedfa5bc147c0876 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a498657a20ee5f8e3dedfa5bc147c0876">KernelTransform</a> (unsigned int <a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a>, unsigned int <a class="el" href="classnetwork_1_1RecurrentTransform.html#a3090f191fda20c346cdb705a16944da6">R</a>, const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;<a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a>)</td></tr>
<tr class="memdesc:a498657a20ee5f8e3dedfa5bc147c0876 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the transform for the given parameters.  <a href="classnetwork_1_1KernelTransform.html#a498657a20ee5f8e3dedfa5bc147c0876">More...</a><br /></td></tr>
<tr class="separator:a498657a20ee5f8e3dedfa5bc147c0876 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d36eb18265e2135100dfebe50dc617f inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a5d36eb18265e2135100dfebe50dc617f">resetWeights</a> ()</td></tr>
<tr class="memdesc:a5d36eb18265e2135100dfebe50dc617f inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits the weights.  <a href="classnetwork_1_1KernelTransform.html#a5d36eb18265e2135100dfebe50dc617f">More...</a><br /></td></tr>
<tr class="separator:a5d36eb18265e2135100dfebe50dc617f inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa4a256f781efb64b5937fcdd7d228 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a03aa4a256f781efb64b5937fcdd7d228">getWeightCount</a> () const</td></tr>
<tr class="memdesc:a03aa4a256f781efb64b5937fcdd7d228 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of weights.  <a href="classnetwork_1_1KernelTransform.html#a03aa4a256f781efb64b5937fcdd7d228">More...</a><br /></td></tr>
<tr class="separator:a03aa4a256f781efb64b5937fcdd7d228 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8378faaac02ee9707b146a15ce9f4e inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#aed8378faaac02ee9707b146a15ce9f4e">getWeight</a> (unsigned int n, unsigned int d) const</td></tr>
<tr class="memdesc:aed8378faaac02ee9707b146a15ce9f4e inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one weight <img class="formulaInl" alt="$W_{nd}$" src="form_93.png"/>.  <a href="classnetwork_1_1KernelTransform.html#aed8378faaac02ee9707b146a15ce9f4e">More...</a><br /></td></tr>
<tr class="separator:aed8378faaac02ee9707b146a15ce9f4e inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb6ef8c5c47e66ab5ef249ec49c010d inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetwork_1_1KernelTransform.html">KernelTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a7bb6ef8c5c47e66ab5ef249ec49c010d">setWeightsRandom</a> (double mean=0.0, double sigma=0.0, bool add=false, <a class="el" href="s__string_8h.html#a342f13820a6f9c4de28e5a0940976db7">String</a> mode=&quot;normal&quot;, int seed=-1)</td></tr>
<tr class="memdesc:a7bb6ef8c5c47e66ab5ef249ec49c010d inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets random or constant weights values.  <a href="classnetwork_1_1KernelTransform.html#a7bb6ef8c5c47e66ab5ef249ec49c010d">More...</a><br /></td></tr>
<tr class="separator:a7bb6ef8c5c47e66ab5ef249ec49c010d inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66398574065f69fdb6c500803dcf4880 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a66398574065f69fdb6c500803dcf4880">getValue</a> (unsigned int n, double t) const</td></tr>
<tr class="memdesc:a66398574065f69fdb6c500803dcf4880 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the discrete-time recurrent equation.  <a href="classnetwork_1_1KernelTransform.html#a66398574065f69fdb6c500803dcf4880">More...</a><br /></td></tr>
<tr class="separator:a66398574065f69fdb6c500803dcf4880 inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5fde673b0363b001f83d392c03c7af inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a3f5fde673b0363b001f83d392c03c7af">getValueDerivative</a> (unsigned int n, double t, unsigned int n_, double t_) const</td></tr>
<tr class="memdesc:a3f5fde673b0363b001f83d392c03c7af inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the discrete-time recurrent equation derivative.  <a href="classnetwork_1_1KernelTransform.html#a3f5fde673b0363b001f83d392c03c7af">More...</a><br /></td></tr>
<tr class="separator:a3f5fde673b0363b001f83d392c03c7af inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153af5b718f3c78ed3ac51f5bcb6b5ba inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#a153af5b718f3c78ed3ac51f5bcb6b5ba">asString</a> () const</td></tr>
<tr class="memdesc:a153af5b718f3c78ed3ac51f5bcb6b5ba inherit pub_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight values as a JSON string.  <a href="classnetwork_1_1KernelTransform.html#a153af5b718f3c78ed3ac51f5bcb6b5ba">More...</a><br /></td></tr>
<tr class="separator:a153af5b718f3c78ed3ac51f5bcb6b5ba inherit pub_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnetwork_1_1RecurrentTransform"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnetwork_1_1RecurrentTransform')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnetwork_1_1RecurrentTransform.html">network::RecurrentTransform</a></td></tr>
<tr class="memitem:a43efdbbe0ac0ce5aa0b493bc90a66d7d inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a43efdbbe0ac0ce5aa0b493bc90a66d7d">RecurrentTransform</a> (unsigned int <a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a>, unsigned int <a class="el" href="classnetwork_1_1RecurrentTransform.html#a3090f191fda20c346cdb705a16944da6">R</a>, const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;<a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a>)</td></tr>
<tr class="memdesc:a43efdbbe0ac0ce5aa0b493bc90a66d7d inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the transform for the given parameters.  <a href="classnetwork_1_1RecurrentTransform.html#a43efdbbe0ac0ce5aa0b493bc90a66d7d">More...</a><br /></td></tr>
<tr class="separator:a43efdbbe0ac0ce5aa0b493bc90a66d7d inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb9f0f4cd8104254893e27dbc36ab10 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnetwork_1_1RecurrentTransform.html">RecurrentTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#adfb9f0f4cd8104254893e27dbc36ab10">reset</a> (bool buffered=false, double upsilon=0)</td></tr>
<tr class="memdesc:adfb9f0f4cd8104254893e27dbc36ab10 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the transform buffering.  <a href="classnetwork_1_1RecurrentTransform.html#adfb9f0f4cd8104254893e27dbc36ab10">More...</a><br /></td></tr>
<tr class="separator:adfb9f0f4cd8104254893e27dbc36ab10 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda575548a0b15c9b0e04bcedd084d24 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#aeda575548a0b15c9b0e04bcedd084d24">getR</a> () const</td></tr>
<tr class="memdesc:aeda575548a0b15c9b0e04bcedd084d24 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximal recurrent range.  <a href="classnetwork_1_1RecurrentTransform.html#aeda575548a0b15c9b0e04bcedd084d24">More...</a><br /></td></tr>
<tr class="separator:aeda575548a0b15c9b0e04bcedd084d24 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb8c4363ba6d1c58ed8d1de4b27957 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a26cb8c4363ba6d1c58ed8d1de4b27957">get</a> (unsigned int n, double t) const</td></tr>
<tr class="memdesc:a26cb8c4363ba6d1c58ed8d1de4b27957 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input value.  <a href="classnetwork_1_1RecurrentTransform.html#a26cb8c4363ba6d1c58ed8d1de4b27957">More...</a><br /></td></tr>
<tr class="separator:a26cb8c4363ba6d1c58ed8d1de4b27957 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ecde264974f4f9a0fed6b3169c9e2e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a28ecde264974f4f9a0fed6b3169c9e2e">set</a> (unsigned int n, double t, double value)</td></tr>
<tr class="memdesc:a28ecde264974f4f9a0fed6b3169c9e2e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an input value of the recurrent equation.  <a href="classnetwork_1_1RecurrentTransform.html#a28ecde264974f4f9a0fed6b3169c9e2e">More...</a><br /></td></tr>
<tr class="separator:a28ecde264974f4f9a0fed6b3169c9e2e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca965fa2811a11719a6642cbf42fd6a1 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#aca965fa2811a11719a6642cbf42fd6a1">getValueDerivativeApproximation</a> (unsigned int n, double t, unsigned int n_, double t_, double epsilon=1e-3) const</td></tr>
<tr class="memdesc:aca965fa2811a11719a6642cbf42fd6a1 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the numerical approximate value derivative.  <a href="classnetwork_1_1RecurrentTransform.html#aca965fa2811a11719a6642cbf42fd6a1">More...</a><br /></td></tr>
<tr class="separator:aca965fa2811a11719a6642cbf42fd6a1 inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98783d4f70a6f0e93f51a70da4d1f2c inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHistogram.html">Histogram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#ae98783d4f70a6f0e93f51a70da4d1f2c">getLyapunovExponent</a> (unsigned int W=10, unsigned int K=10, double d0=1e-6)</td></tr>
<tr class="memdesc:ae98783d4f70a6f0e93f51a70da4d1f2c inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the Lyapunov exponent.  <a href="classnetwork_1_1RecurrentTransform.html#ae98783d4f70a6f0e93f51a70da4d1f2c">More...</a><br /></td></tr>
<tr class="separator:ae98783d4f70a6f0e93f51a70da4d1f2c inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072a765c9202e6de31d97ad572bfc10e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a072a765c9202e6de31d97ad572bfc10e">asString</a> () const</td></tr>
<tr class="memdesc:a072a765c9202e6de31d97ad572bfc10e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transform parameters as a JSON string.  <a href="classnetwork_1_1RecurrentTransform.html#a072a765c9202e6de31d97ad572bfc10e">More...</a><br /></td></tr>
<tr class="separator:a072a765c9202e6de31d97ad572bfc10e inherit pub_methods_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnetwork_1_1Transform"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnetwork_1_1Transform')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnetwork_1_1Transform.html">network::Transform</a></td></tr>
<tr class="memitem:aebaa03b08f17419d600d56d06a274fbb inherit pub_methods_classnetwork_1_1Transform"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Transform.html#aebaa03b08f17419d600d56d06a274fbb">Transform</a> (unsigned int <a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a>, const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;<a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a>)</td></tr>
<tr class="memdesc:aebaa03b08f17419d600d56d06a274fbb inherit pub_methods_classnetwork_1_1Transform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the transform for the given parameters.  <a href="classnetwork_1_1Transform.html#aebaa03b08f17419d600d56d06a274fbb">More...</a><br /></td></tr>
<tr class="separator:aebaa03b08f17419d600d56d06a274fbb inherit pub_methods_classnetwork_1_1Transform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e45886308f85541a2f13f5e5ba76f4 inherit pub_methods_classnetwork_1_1Transform"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Transform.html#a17e45886308f85541a2f13f5e5ba76f4">getInput</a> () const</td></tr>
<tr class="memdesc:a17e45886308f85541a2f13f5e5ba76f4 inherit pub_methods_classnetwork_1_1Transform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transform input.  <a href="classnetwork_1_1Transform.html#a17e45886308f85541a2f13f5e5ba76f4">More...</a><br /></td></tr>
<tr class="separator:a17e45886308f85541a2f13f5e5ba76f4 inherit pub_methods_classnetwork_1_1Transform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnetwork_1_1Input"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnetwork_1_1Input')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnetwork_1_1Input.html">network::Input</a></td></tr>
<tr class="memitem:abae35996fbd286e9828e681809f936ad inherit pub_methods_classnetwork_1_1Input"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Input.html#abae35996fbd286e9828e681809f936ad">Input</a> (unsigned int <a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a>, double <a class="el" href="classnetwork_1_1Input.html#ab6452dd538e399022b9368f93aea5f57">T</a>)</td></tr>
<tr class="memdesc:abae35996fbd286e9828e681809f936ad inherit pub_methods_classnetwork_1_1Input"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the input dimensions.  <a href="classnetwork_1_1Input.html#abae35996fbd286e9828e681809f936ad">More...</a><br /></td></tr>
<tr class="separator:abae35996fbd286e9828e681809f936ad inherit pub_methods_classnetwork_1_1Input"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c529ec00fb12ae19fcdfea6c5a2fca2 inherit pub_methods_classnetwork_1_1Input"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Input.html#a4c529ec00fb12ae19fcdfea6c5a2fca2">getN</a> () const</td></tr>
<tr class="memdesc:a4c529ec00fb12ae19fcdfea6c5a2fca2 inherit pub_methods_classnetwork_1_1Input"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of input units.  <a href="classnetwork_1_1Input.html#a4c529ec00fb12ae19fcdfea6c5a2fca2">More...</a><br /></td></tr>
<tr class="separator:a4c529ec00fb12ae19fcdfea6c5a2fca2 inherit pub_methods_classnetwork_1_1Input"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dea69d6f4f438bdd37df45d5c341382 inherit pub_methods_classnetwork_1_1Input"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Input.html#a3dea69d6f4f438bdd37df45d5c341382">getT</a> () const</td></tr>
<tr class="memdesc:a3dea69d6f4f438bdd37df45d5c341382 inherit pub_methods_classnetwork_1_1Input"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximal time range.  <a href="classnetwork_1_1Input.html#a3dea69d6f4f438bdd37df45d5c341382">More...</a><br /></td></tr>
<tr class="separator:a3dea69d6f4f438bdd37df45d5c341382 inherit pub_methods_classnetwork_1_1Input"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classnetwork_1_1KernelTransform"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classnetwork_1_1KernelTransform')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classnetwork_1_1KernelTransform.html">network::KernelTransform</a></td></tr>
<tr class="memitem:acd9c18a080048bf93b20502ffc7284f7 inherit pub_static_methods_classnetwork_1_1KernelTransform"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnetwork_1_1KernelTransform.html">KernelTransform</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1KernelTransform.html#acd9c18a080048bf93b20502ffc7284f7">newKernelTransform</a> (<a class="el" href="s__string_8h.html#a342f13820a6f9c4de28e5a0940976db7">String</a> type, unsigned int <a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a>, const <a class="el" href="classnetwork_1_1Input.html">network::Input</a> &amp;<a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a>)</td></tr>
<tr class="memdesc:acd9c18a080048bf93b20502ffc7284f7 inherit pub_static_methods_classnetwork_1_1KernelTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classnetwork_1_1KernelTransform.html" title="Defines a discrete-time recurrent input/output kernel transform. ">KernelTransform</a> of a given implemented type.  <a href="classnetwork_1_1KernelTransform.html#acd9c18a080048bf93b20502ffc7284f7">More...</a><br /></td></tr>
<tr class="separator:acd9c18a080048bf93b20502ffc7284f7 inherit pub_static_methods_classnetwork_1_1KernelTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classnetwork_1_1RecurrentTransform"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classnetwork_1_1RecurrentTransform')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classnetwork_1_1RecurrentTransform.html">network::RecurrentTransform</a></td></tr>
<tr class="memitem:a3090f191fda20c346cdb705a16944da6 inherit pro_attribs_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a3090f191fda20c346cdb705a16944da6">R</a></td></tr>
<tr class="separator:a3090f191fda20c346cdb705a16944da6 inherit pro_attribs_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af72e32e6843f51bd0d99684f2f19c7 inherit pro_attribs_classnetwork_1_1RecurrentTransform"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1RecurrentTransform.html#a8af72e32e6843f51bd0d99684f2f19c7">L</a></td></tr>
<tr class="separator:a8af72e32e6843f51bd0d99684f2f19c7 inherit pro_attribs_classnetwork_1_1RecurrentTransform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classnetwork_1_1Transform"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classnetwork_1_1Transform')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classnetwork_1_1Transform.html">network::Transform</a></td></tr>
<tr class="memitem:a7cbe29c970df43f5cce3b7fb35b07a9d inherit pro_attribs_classnetwork_1_1Transform"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Transform.html#a7cbe29c970df43f5cce3b7fb35b07a9d">input</a></td></tr>
<tr class="separator:a7cbe29c970df43f5cce3b7fb35b07a9d inherit pro_attribs_classnetwork_1_1Transform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classnetwork_1_1Input"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classnetwork_1_1Input')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classnetwork_1_1Input.html">network::Input</a></td></tr>
<tr class="memitem:a0ddc53e14e3db843da7c6c3c527348ab inherit pro_attribs_classnetwork_1_1Input"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Input.html#a0ddc53e14e3db843da7c6c3c527348ab">N</a></td></tr>
<tr class="separator:a0ddc53e14e3db843da7c6c3c527348ab inherit pro_attribs_classnetwork_1_1Input"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6452dd538e399022b9368f93aea5f57 inherit pro_attribs_classnetwork_1_1Input"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork_1_1Input.html#ab6452dd538e399022b9368f93aea5f57">T</a></td></tr>
<tr class="separator:ab6452dd538e399022b9368f93aea5f57 inherit pro_attribs_classnetwork_1_1Input"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a recurrent network as a non-linear affine combination of input and recurrent values. </p>
<ul>
<li>Such recurrent network writes: <center> <img class="formulaInl" alt="$\begin{array}{rcl} x_n(t) &amp;=&amp; x_{n_1}(t) + \zeta_{[min,max]}\left(x_{n_2}(t)\right) \\ x_{n_1}(t) &amp;=&amp; \gamma_n \, x_{n}(t-1) \\ x_{n_2}(t) &amp;=&amp; \alpha_n + \sum_{n' = 0}^{N-1} W_{nn'} \, x_{n'}(t-1) + \sum_{m = 0}^{M-1} W_{nm} \, i_m(t-1) \\ \end{array}$" src="form_107.png"/></center> <b>Weight organization</b>: <table class="doxtable">
<tr>
<th><img class="formulaInl" alt="$(n,d)$" src="form_27.png"/> </th><th></th><th></th></tr>
<tr>
<td><img class="formulaInl" alt="$(n+N,1)$" src="form_52.png"/> </td><td></td><td>Unit leak <img class="formulaInl" alt="$\gamma_n \in [0, 0.999]$" src="form_48.png"/> </td></tr>
<tr>
<td><img class="formulaInl" alt="$(n+2\,N,1)$" src="form_108.png"/> </td><td></td><td>Unit offset <img class="formulaInl" alt="$\alpha_n$" src="form_29.png"/> </td></tr>
<tr>
<td><img class="formulaInl" alt="$(n+2\,N,2+n')$" src="form_109.png"/> </td><td><img class="formulaInl" alt="$n' \in \{0,N\{$" src="form_31.png"/> </td><td>Recurrent weights <img class="formulaInl" alt="$W_{nn'}$" src="form_32.png"/> </td></tr>
<tr>
<td><img class="formulaInl" alt="$(n+2\,N,2+N+m)$" src="form_110.png"/> </td><td><img class="formulaInl" alt="$m \in \{0,M\{$" src="form_34.png"/> </td><td><a class="el" href="classnetwork_1_1Input.html" title="Defines the input of a calculation network. ">Input</a> weights <img class="formulaInl" alt="$W_{nm}$" src="form_35.png"/> </td></tr>
</table>
with <img class="formulaInl" alt="$n_1 = N - n, n_2 = 2\,N - n$" src="form_111.png"/>.</li>
<li>In order to avoid unbounded values, when using a ReLU profile, a saturation at <img class="formulaInl" alt="$\pm10^{6}$" src="form_43.png"/> is introduced. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8hpp_source.html#l00019">19</a> of file <a class="el" href="LinearNonLinearTransform_8hpp_source.html">LinearNonLinearTransform.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1b3138ecf9ee9311dc976ae252ddc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b3138ecf9ee9311dc976ae252ddc47">&#9670;&nbsp;</a></span>LinearNonLinearTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">network::LinearNonLinearTransform::LinearNonLinearTransform </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnetwork_1_1Input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the transform for the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of input units, defined unit indexes stand in <code>{0, N{</code>.<ul>
<li>The network has <code>3\,N</code> nodes. </li>
</ul>
</td></tr>
    <tr><td class="paramname">input</td><td>The transform input. </td></tr>
    <tr><td class="paramname">min</td><td>The minimal value of the sigmoid non-linearity. </td></tr>
    <tr><td class="paramname">max</td><td>The maximal value of the sigmoid non-linearity. If <code>max == INFINITY</code> defines a ReLU, i.e. a rectification, i.e. <img class="formulaInl" alt="$\zeta_{[min,\infty]}\left(u\right) = min + u \, H(u)$" src="form_112.png"/>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00018">18</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="assume_8c_source.html#l00007">assume()</a>, <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00025">setLeak()</a>, and <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00035">setOffset()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad12d9519a67bfbe56017dc7134a24398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12d9519a67bfbe56017dc7134a24398">&#9670;&nbsp;</a></span>setLeak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html">network::LinearNonLinearTransform</a> &amp; network::LinearNonLinearTransform::setLeak </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a fixed common leak for this network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The leak value of all <img class="formulaInl" alt="$\gamma_n$" src="form_55.png"/>, NAN to unconstrain the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00025">25</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00045">setWeight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00018">LinearNonLinearTransform()</a>.</p>

</div>
</div>
<a id="ab9d028cfab0d62f57e291148403ec361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d028cfab0d62f57e291148403ec361">&#9670;&nbsp;</a></span>setOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork_1_1LinearNonLinearTransform.html">network::LinearNonLinearTransform</a> &amp; network::LinearNonLinearTransform::setOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a fixed common offset for this network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The offset value of all <img class="formulaInl" alt="$\alpha_n$" src="form_29.png"/>, NAN to unconstrain the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00035">35</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00045">setWeight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00018">LinearNonLinearTransform()</a>.</p>

</div>
</div>
<a id="aeba94b5729e4757f472b995bdac593b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba94b5729e4757f472b995bdac593b0">&#9670;&nbsp;</a></span>setWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool network::LinearNonLinearTransform::setWeight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets one weight <img class="formulaInl" alt="$W_{nd}$" src="form_93.png"/> value. </p>
<ul>
<li>This routine is to be overriden if the weights are bounded (e.g. if positive). A typical implementation writes, e.g.:<pre>
 bool <a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#aeba94b5729e4757f472b995bdac593b0" title="Sets one weight  value. ">setWeight(unsigned int n, unsigned int d, double w)</a> {
   // Constraint the weight of idex 0 to be positive
   if (d == 0 &amp;&amp; w &lt; 0) {
     setWeight(n, d, 0);
     return false;
   } else
     return setWeight(n, d, d);
 }</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The state unit index in <code>{0, N{</code>. </td></tr>
    <tr><td class="paramname">d</td><td>The recurrent kernel index in <code>{1, <a class="el" href="classnetwork_1_1LinearNonLinearTransform.html#a02badcd07dba1d066a5471082851a5ce" title="Returns the recurrent kernel dimension. ">getKernelDimension()</a>}</code>. </td></tr>
    <tr><td class="paramname">w</td><td>The weight value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is inside the bounds, false if the value has been bounded, i.e. is equal to the bound or outside the bound. </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1KernelTransform.html#a4625a8752d531614e4ea61eecc6a415b">network::KernelTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00045">45</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelTransform_8cpp_source.html#l00051">network::KernelTransform::setWeight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00025">setLeak()</a>, <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00035">setOffset()</a>, and <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00055">setWeights()</a>.</p>

</div>
</div>
<a id="a90a3472af1a3934f8824586dbf701024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a3472af1a3934f8824586dbf701024">&#9670;&nbsp;</a></span>setWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork_1_1KernelTransform.html">network::KernelTransform</a> &amp; network::LinearNonLinearTransform::setWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnetwork_1_1KernelTransform.html">KernelTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets weights from another network of the same type. </p>
<ul>
<li>By contract weights are copied considering the 1st units, if both network do not have the same number of units.</li>
<li>By contract weights are copied if and only if both network are of the same type and each KerneTransform must implement this method and test the type dynamically via construct of the form:<pre>assume(dynamic_cast&lt;$transform-type *&gt;(&amp;network) != NULL, "illegal-argument", "in network::$transform-type::setWeights wrong network type");</pre>. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The weights source network. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1KernelTransform.html#a3c4cd65233c48026dddadad6131f6c46">network::KernelTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00055">55</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="assume_8c_source.html#l00007">assume()</a>, <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00065">getKernelDimension()</a>, <a class="el" href="Input_8hpp_source.html#l00017">network::Input::getN()</a>, <a class="el" href="KernelTransform_8hpp_source.html#l00086">network::KernelTransform::getWeight()</a>, and <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00045">setWeight()</a>.</p>

</div>
</div>
<a id="a02badcd07dba1d066a5471082851a5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02badcd07dba1d066a5471082851a5ce">&#9670;&nbsp;</a></span>getKernelDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int network::LinearNonLinearTransform::getKernelDimension </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the recurrent kernel dimension. </p>
<ul>
<li>The method is to be overwritten to implement a given transform. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The state unit index in <code>{0, N{</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state unit recurrent kernel dimension. </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1KernelTransform.html#a5472cb053b6ae5f597042297ff20a236">network::KernelTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00065">65</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="Input_8hpp_source.html#l00017">network::Input::getN()</a>, and <a class="el" href="Transform_8hpp_source.html#l00005">network::Transform::input</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00055">setWeights()</a>.</p>

</div>
</div>
<a id="a68f34369e316221ac0df9cf146710a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f34369e316221ac0df9cf146710a5e">&#9670;&nbsp;</a></span>getKernelValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double network::LinearNonLinearTransform::getKernelValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the recurrent kernel value. </p>
<ul>
<li>The method is to be overwritten to implement a given transform.</li>
<li>The method uses input.get() and <a class="el" href="classnetwork_1_1RecurrentTransform.html#a26cb8c4363ba6d1c58ed8d1de4b27957" title="Returns the input value. ">get()</a> to get the related input or state values.</li>
<li>The method has not to be protected against illegal-argument, since invoked by a safe method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The state unit index in <code>{0, N{</code>. </td></tr>
    <tr><td class="paramname">d</td><td>The recurrent kernel index in <code>{0, getKernelDimension(n)}</code>. </td></tr>
    <tr><td class="paramname">t</td><td>The time index in <code>{0, T{</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding kernel value <img class="formulaInl" alt="$\Phi_{ndt}\left(\cdots, x_{n'}[t'], \cdots, I_{m}[s], \cdots\right)$" src="form_89.png"/>. </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1KernelTransform.html#a06bfef1a45772c9212d3dcba92d4716b">network::KernelTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00069">69</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

<p class="reference">References <a class="el" href="Input_8cpp_source.html#l00004">network::Input::get()</a>, <a class="el" href="Input_8hpp_source.html#l00017">network::Input::getN()</a>, and <a class="el" href="Transform_8hpp_source.html#l00005">network::Transform::input</a>.</p>

</div>
</div>
<a id="ae9a2543d39307d2b02ea6c67d4923a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a2543d39307d2b02ea6c67d4923a4b">&#9670;&nbsp;</a></span>getKernelDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double network::LinearNonLinearTransform::getKernelDerivative </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the recurrent kernel derivative with respect to a recurrent state value. </p>
<ul>
<li>The method is to be overwritten to implement a given transform.</li>
<li>The method uses input.get() and <a class="el" href="classnetwork_1_1RecurrentTransform.html#a26cb8c4363ba6d1c58ed8d1de4b27957" title="Returns the input value. ">get()</a> to get the related input or state values.</li>
<li>The method has not to be protected against illegal-argument, since invoked by a safe method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The state unit index in <code>{0, N{</code>. </td></tr>
    <tr><td class="paramname">d</td><td>The recurrent kernel index in <code>{0, getKernelDimension(n)}</code>. </td></tr>
    <tr><td class="paramname">t</td><td>The state time index in <code>{0, T{</code>. </td></tr>
    <tr><td class="paramname">n_</td><td>The recurrent unit index in <code>{0, N{</code>. </td></tr>
    <tr><td class="paramname">t_</td><td>The recurrent time index in <code>{t-R, t{</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0.0</code> if <img class="formulaInl" alt="$x_n[t]$" src="form_90.png"/> does not depend on <img class="formulaInl" alt="$x_k[s]$" src="form_91.png"/>, else <img class="formulaInl" alt="$\frac{\partial \phi_{ndt}}{\partial x_k[s]}$" src="form_92.png"/>. </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1KernelTransform.html#a14c55c881f27f8926a530bb3df79a4e0">network::KernelTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00089">89</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

</div>
</div>
<a id="a13a6ee5939a5051ac924e0448d76ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a6ee5939a5051ac924e0448d76ecfd">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool network::LinearNonLinearTransform::isConnected </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two units are connected. </p>
<ul>
<li>The method is to be overwritten to implement sparse connected networks. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The efferent input unit index. </td></tr>
    <tr><td class="paramname">t</td><td>The efferent input unit current time. </td></tr>
    <tr><td class="paramname">n_</td><td>The afferent input unit index denominator. </td></tr>
    <tr><td class="paramname">t_</td><td>The afferent input unit current time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the unit of index <code>n_</code> never connects to the unit of index <code>n</code>, for the given times, true if the connection is to be checked via <a class="el" href="classnetwork_1_1KernelTransform.html#a3f5fde673b0363b001f83d392c03c7af" title="Implements the discrete-time recurrent equation derivative. ">getValueDerivative()</a> </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classnetwork_1_1RecurrentTransform.html#acf36f1cd1e1b6fb99af4f9929c349786">network::RecurrentTransform</a>.</p>

<p class="definition">Definition at line <a class="el" href="LinearNonLinearTransform_8cpp_source.html#l00097">97</a> of file <a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/network/<a class="el" href="LinearNonLinearTransform_8hpp_source.html">LinearNonLinearTransform.hpp</a></li>
<li>src/network/<a class="el" href="LinearNonLinearTransform_8cpp_source.html">LinearNonLinearTransform.cpp</a></li>
</ul>
</div><!-- contents -->
<hr/><div align='right'><tt>mnemosyne brainybot (version of 2018-02-02 at 08:26:13) </tt> </div><hr/>
